#!/usr/bin/env python
"""
Usage: finn [options]

Options:
  -f, --foce                 Force regeneration
  -h, --help                 Show this help message and exit
"""
import datetime
import fnmatch
import itertools
import optparse
import os
import sys

from jinja2 import Environment, FileSystemLoader
from markdown import markdown


ENV = Environment(loader=FileSystemLoader('templates'))


def helper(*args, **kwargs):
    sys.stderr.write(__doc__.strip() + '\n')
    sys.exit(0)


def render_file(filename, template, **context):
    filename = os.path.join('build', filename.strip('/'))
    dirname = os.path.dirname(filename)
    if not os.path.isdir(dirname):
        os.makedirs(dirname)

    t = ENV.get_template(template)
    with open(filename, 'w') as f:
        f.write(t.render(**context).encode('utf-8'))


def rglob(dir, pattern):
    matches = []
    for root, dirnames, filenames in os.walk(dir):
      for filename in fnmatch.filter(filenames, pattern):
          matches.append(os.path.join(root, filename))
    return matches


class Entry(object):

    def __init__(self, filename):
        fh = open(filename, 'r').read().decode('utf-8')
        self.head, self.body = fh.split('\n\n', 1)
        for header in self.head.split('\n'):
            key, value = header.split(': ', 1)
            setattr(self, key.lower(), value)

        self.date = datetime.datetime.strptime(self.date, '%Y-%m-%d %H:%M:%S')
        self.source = os.path.abspath(filename)

    def __repr__(self):
        return self.title

    @property
    def changed(self):
        dest = os.path.abspath(os.path.join('build', self.dest))
        try:
            mdest = os.path.getmtime(dest)
            msource = os.path.getmtime(self.source)
            return msource > mdest
        except:
            return True

    @property
    def html(self):
        return markdown(self.body)

    @property
    def dest(self):
        return os.path.join(self.date.strftime("%Y/%m/%d/"), self.slug + '.html')

    @property
    def path(self):
        return os.path.splitext(self.dest)[0]


class Page(Entry):
    @property
    def dest(self):
        return self.slug + '.html'


if __name__ == '__main__':
    parser = optparse.OptionParser()
    parser.remove_option('--help')
    parser.add_option('-h', '--help', action='callback', callback=helper)
    parser.add_option('-f', '--force', dest='force', action='store_true', default=False)
    options, args = parser.parse_args()

    pages = map(Page, rglob('source/pages', '*.markdown'))
    posts = map(Entry, rglob('source/posts', '*.markdown'))
    posts.sort(key=lambda x: x.date, reverse=True)
    yearly = itertools.groupby(posts, lambda x: x.date.strftime("%Y"))
    monthly = itertools.groupby(posts, lambda x: x.date.strftime("%Y/%m"))
    daily = itertools.groupby(posts, lambda x: x.date.strftime("%Y/%m/%d"))

    for page in pages:
        if page.changed or options.force:
            render_file(page.dest, 'page.html', entry=page)

    for year, yearly_posts in yearly:
        results = {}
        months = []
        posts_by_month = itertools.groupby(yearly_posts, lambda x: x.date.strftime("%m-%B"))
        for month, _ in posts_by_month:
            months.append(month.split('-'))
        results[year] = sorted(months)
        filename = os.path.join(year, 'index.html')
        render_file(filename, 'year.html', posts=results, year=year)

    for span in [monthly, daily]:
        for group in span:
            filename = os.path.join(group[0], 'index.html')
            render_file(filename, 'base.html', posts=group[1])

    for entry in posts:
        if entry.changed or options.force:
            render_file(entry.dest, 'entry.html', post=post)

    render_file('index.html', 'base.html', posts=posts[:30])
